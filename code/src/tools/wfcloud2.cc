//------------------------------------------------------------------------------
//  wfcloud2.cc
//  
//  Takes a closed 3d mesh, generates a point cloud inside the mesh by
//  shooting a grid of rays into it, treats each point as a cloud particle
//  and computes the distances to the clouds surface along -x, +x, -y, +y, -z 
//  and +z. The result is saved into a n3d file (same format as the one
//  generated by wfcloud.cc
//
//  (C) 2001 A.Weissflog
//------------------------------------------------------------------------------
#include "kernel/ntypes.h"
#include "tools/wfobject.h"
#include "tools/wftools.h"
#include "opcode/opcode.h"
#include "mathlib/bbox.h"

using namespace Opcode;

// some global variables (initialized in createOpcModel())
vector3* Vertices            = 0;
int* Indices                 = 0;
CollisionFaces* CollFaces    = 0;
Model* OpcModel       = 0;
MeshInterface* opcMeshInterface = 0;
RayCollider* aRayCollider = 0;
float* DistanceArray         = 0;

enum DIRECTION
{
    TOP    = 0,     // +y -> -y
    BOTTOM = 1,     // -y -> +y
    SOUTH  = 2,     // +z -> -z
    NORTH  = 3,     // -z -> +z
    EAST   = 4,     // +x -> -x
    WEST   = 5,     // -x -> +x
};

//------------------------------------------------------------------------------
/**
    This callback is called by opcode to convert a vertex index into
    a pointer to the vertex coordinate.
*/
//void
//opcCallback(udword triangleIndex, VertexPointers& triangle, udword /*userData*/)
//{
//    int* indexPtr = &(Indices[3 * triangleIndex]);
//    triangle.Vertex[0] = (Point*) &(Vertices[indexPtr[0]]);
//    triangle.Vertex[1] = (Point*) &(Vertices[indexPtr[1]]);
//    triangle.Vertex[2] = (Point*) &(Vertices[indexPtr[2]]);
//}

//------------------------------------------------------------------------------
/**
    Generate a OPCODE model from a wfObject. Initializes the global
    Vertices and Indices pointers. Initializes a global ray collider object.
*/
void startupOpcode(wfObject& src)
{
    n_assert(0 == Vertices);
    n_assert(0 == Indices);
    n_assert(0 == CollFaces);
    n_assert(0 == OpcModel);
    n_assert(0 == aRayCollider);

    // allocate vertex and triangle index array
    int numVerts = src.v_array.Size();
    int numTris  = src.f_array.Size();
    int i;
    Vertices  = new vector3[numVerts];
    Indices   = new int[3 * numTris];
    DistanceArray = new float[numTris];

    // copy vertices    
    for (i = 0; i < numVerts; i++)
    {
        const vector3& v = src.v_array.At(i).v;
        Vertices[i] = v;
    }
    // copy triangle indices
    for (i = 0; i < numTris; i++)
    {
        wfFace& curFace = src.f_array.At(i);
        wfPoint& p0 = curFace.points.At(0);
        wfPoint& p1 = curFace.points.At(1);
        wfPoint& p2 = curFace.points.At(2);
        Indices[3*i + 0] = p0.v_index;
        Indices[3*i + 1] = p1.v_index;
        Indices[3*i + 2] = p2.v_index;
    }
    
    // create and initialize opcode model
    OpcModel = new Model();
    opcMeshInterface = new MeshInterface();
    opcMeshInterface->SetNbTriangles(numTris);
    opcMeshInterface->SetNbVertices(numVerts);
    // not using callbacks anymore in order to comply with ODE tri-collider
    //opcMeshInterface.SetCallback(nOpcodeShape::collCallback, this);
    opcMeshInterface->SetPointers((IndexedTriangle*)Indices, (Point*)Vertices);
    opcMeshInterface->SetStrides(sizeof(int) * 3, sizeof(float) * 3);
       
    OPCODECREATE opcc;
    opcc.mIMesh = opcMeshInterface;
    opcc.mSettings.mRules   = SPLIT_SPLATTER_POINTS;
    opcc.mNoLeaf    = false;
    opcc.mQuantized = false;
    OpcModel->Build(opcc);

    // create collision faces container
    CollFaces = new CollisionFaces;

    // create and initialize ray collider
    aRayCollider = new RayCollider;
    aRayCollider->SetFirstContact(false);         // report all contacts
    aRayCollider->SetTemporalCoherence(false);    // no temporal coherence
    aRayCollider->SetClosestHit(false);           // all hits
    aRayCollider->SetCulling(false);              // no backface culling
    aRayCollider->SetMaxDist(1000000.0f);
    aRayCollider->SetDestination(CollFaces);      // detected hits go here
    //aRayCollider->SetCallback(opcCallback, 0);    // called back by OPCODE to get vertex coords
    const char* res = aRayCollider->ValidateSettings();
    n_assert(res == 0);
}

//------------------------------------------------------------------------------
/**
    Release opcModel and global arrays created in createOpcModel()
*/
void
shutdownOpcode()
{
    n_assert(OpcModel);
    n_assert(opcMeshInterface);
    n_assert(aRayCollider);
    n_assert(Vertices);
    n_assert(Indices);
    n_assert(CollFaces);
    n_assert(DistanceArray);

    delete OpcModel;
    delete opcMeshInterface;
    delete aRayCollider;
    delete CollFaces;
    delete[] Vertices;
    delete[] Indices;
    delete[] DistanceArray;
    OpcModel    = 0;
    opcMeshInterface = 0;
    aRayCollider = 0;
    Vertices    = 0;
    Indices     = 0;
    CollFaces   = 0;
    DistanceArray = 0;
}

//------------------------------------------------------------------------------
/**
*/
int
compare(const void* elm1, const void* elm2)
{
    float f1 = *((float*)elm1);
    float f2 = *((float*)elm2);
    if (f1 < f2)      return -1;
    else if (f1 > f2) return +1;
    else              return 0;
}

//------------------------------------------------------------------------------
/**
    Sorts the intersections in the CollFaces object into the DistanceArray.
    removes duplicates, returns number of entries in collarray.
*/
int
sortIntersections()
{
    n_assert(DistanceArray);
    n_assert(CollFaces);

    const CollisionFace* collArray = CollFaces->GetFaces();
    int numColls = CollFaces->GetNbFaces();
    float* array = DistanceArray;

    // copy and sort distances
    int i;
    for (i = 0; i < numColls; i++)
    {
        array[i] = collArray[i].mDistance;
    }
    qsort(array, numColls, sizeof(float), compare);

    // remove duplicates
    for (i = 1; i < numColls; i++)
    {
        if (array[i] == array[i-1])
        {
            // remove duplicate by shifting remainder of array one back
            memmove(&(array[i]), &(array[i+1]), (numColls - i) * sizeof(float));
            numColls--;
        }
    }
    return numColls;
}

//------------------------------------------------------------------------------
/**
    Shoots rays into a mesh represendet by the global OPCODE_Model and generates an 
    ordered point cloud with points that are inside or on the surface of 
    the mesh. The points will be written to the provided destination wfObject.

    The global variables Vertices, Indices and CollFaces must be valid!

    @param  src         the source wfObject
    @param  dst         the destination wfObject
    @param  subdiv      number of subdivisions along longest axis
*/
float
writePointCloud(wfObject& src, wfObject& dst, float subdiv)
{
    n_assert(Vertices);
    n_assert(Indices);
    n_assert(OpcModel);
    n_assert(aRayCollider);
    n_assert(subdiv > 0.0f);

    // create bounding box of the mesh
    bbox3 bbox(Vertices, src.v_array.Size());

    // an identity world matrix
    Matrix4x4 world;
    world.Identity();

    // shoot grid of x-axis-aligned rays through the object
    float minZ = bbox.vmin.z;
    float maxZ = bbox.vmax.z;
    float minY = bbox.vmin.y;
    float maxY = bbox.vmax.y;
    float minX = bbox.vmin.x;
    float maxX = bbox.vmax.x;
    float radius = maxZ - minZ;
    if ((maxY - minY) > radius) radius = maxY - minY;
    if ((maxX - minX) > radius) radius = maxX - minX;
    float dist = radius / subdiv;

    minZ -= dist * 0.5f;
    maxZ += dist * 0.5f;
    minY -= dist * 0.5f;
    maxY += dist * 0.5f;
    minX -= dist * 0.5f;
    maxX += dist * 0.5f;


    float curZ, curY;
    Ray ray;
    for (curZ = minZ; curZ < maxZ; curZ += dist)
    {
        for (curY = minY; curY < maxY; curY += dist)
        {
            // build an OPCODE ray from the current coordinates
            ray.mOrig.Set(minX + 0.003f, curY + 0.002f, curZ + 0.001f);
            ray.mDir.Set(1.0f, 0.0f, 0.0f);

            // perform Collision check
            aRayCollider->Collide(ray, *OpcModel, &world);

            // any contacts?
            if (aRayCollider->GetContactStatus())
            {
                // get sorted intersection array, duplicates removed
                int numColls = sortIntersections();
                bool inside = false;
                
                // ignore if odd number of intersections
                if (numColls & 1) continue;
                int curColl  = 0;
                n_assert(numColls > 0);
                float curX;
                for (curX = 0.0f; curX < (maxX - minX); curX += dist)
                {
                    if ((curColl < numColls) && (curX > DistanceArray[curColl]))
                    {
                        inside = !inside;
                        curColl++;
                    }

                    // record position if currently inside
                    if (inside)
                    {
                        wfCoord coord(curX + minX, curY, curZ);
                        dst.v_array.PushBack(coord);
                    }
                }
            }
        }
    }
    return dist;
}

//------------------------------------------------------------------------------
/**
    Shoot a ray from a particle position into one direction and return the
    distance to the cloud surface in that direction.
*/
float 
insideCloudDist(const vector3& pos, DIRECTION dir, float radius)
{
    // get direction vector
    vector3 dirVec;
    switch (dir)
    {
        case TOP:
            dirVec.set(0.0f, -1.0f, 0.0f);
            break;
        case BOTTOM:
            dirVec.set(0.0f, +1.0f, 0.0f);
            break;
        case SOUTH:
            dirVec.set(0.0f, 0.0f, -1.0f);        
            break;
        case NORTH:
            dirVec.set(0.0f, 0.0f, +1.0f);        
            break;
        case EAST:
            dirVec.set(-1.0f, 0.0f, 0.0f);        
            break;
        case WEST:
            dirVec.set(+1.0f, 0.0f, 0.0f);        
            break;
    }

    // build an OPCODE ray from the current coordinates
    Ray ray;
    vector3 posVec(pos.x + 0.001f, pos.y + 0.002f, pos.z + 0.003f);

    ray.mOrig.Set(posVec.x, posVec.y, posVec.z);
    ray.mDir.Set(dirVec.x, dirVec.y, dirVec.z);

    // perform Collision check
    Matrix4x4 world;
    world.Identity();
    aRayCollider->Collide(ray, *OpcModel, &world);
    
    // there must be at least one intersection!
    float dist = 0.0f;
    if (aRayCollider->GetContactStatus())
    {
        // get sorted intersection array, duplicates removed
        sortIntersections();

        // only take the first intersection
        dist = DistanceArray[0] - radius;
        if (dist < 0.0f) dist = 0.0f;
    }
    return dist;
}

//------------------------------------------------------------------------------
/**
    Return a random number between minVal and maxVal.
*/
float
randMinMax(float minVal, float maxVal)
{
    float r = float(rand()) / float(RAND_MAX);
    return minVal + ((maxVal - minVal) * r);
}

//------------------------------------------------------------------------------
/**
    Randomize position and radius of cloud balls.
*/
void
randomize(wfObject& obj, float posTolerance, float radiusTolerance, float /*attTolerance*/)
{
    int num = obj.v_array.Size();
    int i;
    for (i = 0; i < num; i++)
    {
        vector3& pos = obj.v_array.At(i).v;
        float xAdd = randMinMax(-posTolerance, +posTolerance);
        float yAdd = randMinMax(-posTolerance, +posTolerance);
        float zAdd = randMinMax(-posTolerance, +posTolerance);

        pos.x += xAdd;
        pos.y += yAdd;
        pos.z += zAdd;

        obj.vt_array.At(i).x += randMinMax(-radiusTolerance, +radiusTolerance);
    }
}

//------------------------------------------------------------------------------
/**
    Compute light attenuation values for the 6 main directions (up, down,
    north, south, east, west) and write them into dst. We just
    compute the distance of the particle to the cloud's surface.
*/
void
writeAttenuation(wfObject& /*src*/, wfObject& dst, float /*dist*/)
{
    // for each point...
    int num = dst.v_array.Size();
    int i;
    for (i = 0; i < num; i++)
    {
        // get current particle pos
        vector3& pos = dst.v_array.At(i).v;
        float radius = dst.vt_array.At(i).x;

        // get distance inside cloud along the 6 main directions
        float att[6];
        att[0] = insideCloudDist(pos, TOP, radius);
        att[1] = insideCloudDist(pos, BOTTOM, radius);
        att[2] = insideCloudDist(pos, SOUTH, radius);
        att[3] = insideCloudDist(pos, NORTH, radius);
        att[4] = insideCloudDist(pos, EAST, radius);
        att[5] = insideCloudDist(pos, WEST, radius);

        // encode attenuation values into texture coords
        vector2 v0(att[0], att[1]);
        vector2 v1(att[2], att[3]);
        vector2 v2(att[4], att[5]);
        dst.vt1_array.PushBack(v0);
        dst.vt2_array.PushBack(v1);
        dst.vt3_array.PushBack(v2);

        // put the min attenuation into the v component of texture layer 0
        float minAtt = att[0];
        int j;
        for (j = 1; j < 6; j++)
        {
            if (att[j] < minAtt) minAtt = att[j];
        }
        dst.vt_array.At(i).y = minAtt;
    }
}

//------------------------------------------------------------------------------
/**
    Removes particles which are more then maxDist meters inside the cloud.
*/
void
removeInnerParticles(wfObject& obj, float maxDist)
{
    nArray<wfCoord>::iterator curCoord = obj.v_array.Begin();
    nArray<vector2>::iterator curVt0   = obj.vt_array.Begin();
    nArray<vector2>::iterator curVt1   = obj.vt1_array.Begin();
    nArray<vector2>::iterator curVt2   = obj.vt2_array.Begin();
    nArray<vector2>::iterator curVt3   = obj.vt3_array.Begin();

    for (; curCoord < obj.v_array.End();)
    {
        vector2& att01 = *curVt1;
        vector2& att23 = *curVt2;
        vector2& att45 = *curVt3;
        
        float minAtt = att01.x;
        if (att01.y < minAtt) minAtt = att01.y;
        if (att23.x < minAtt) minAtt = att23.x;
        if (att23.y < minAtt) minAtt = att23.y;
        if (att45.x < minAtt) minAtt = att45.x;
        if (att45.y < minAtt) minAtt = att45.y;
        
        if (minAtt > maxDist)
        {
            // remove this cloud ball
//            fprintf(stderr, "remove ball at (%f,%f,%f), minDist = %f\n", curCoord->v.x, curCoord->v.y, curCoord->v.z, minAtt);
            curCoord = obj.v_array.Erase(curCoord);
            curVt0   = obj.vt_array.Erase(curVt0);
            curVt1   = obj.vt1_array.Erase(curVt1);
            curVt2   = obj.vt2_array.Erase(curVt2);
            curVt3   = obj.vt3_array.Erase(curVt3);
        }
        else
        {
            curCoord++;
            curVt0++;
            curVt1++;
            curVt2++;
            curVt3++;
        }
    }
}

//------------------------------------------------------------------------------
/**
    Write radius for each point particle into dst object. The radius
    for each particle is written into the u coordinate of texture
    layer 0.
*/
void
writeRadius(wfObject& /*src*/, wfObject& dst, float dist)
{
    // FIXME: currently simply use 'dist' as radius
    int num = dst.v_array.Size();
    int i;
    for (i = 0; i < num; i++)
    {
        vector2 v(dist, 0.0f);
        dst.vt_array.PushBack(v);
    }
}

//------------------------------------------------------------------------------
/**
*/
void
doit(wfObject& src, wfObject& dst, float subdiv)
{
    fprintf(stderr, "-> generating point cloud...\n");
    float dist = writePointCloud(src, dst, subdiv);
    fprintf(stderr, "-> generating radius...\n");
    writeRadius(src, dst, dist);
    fprintf(stderr, "-> generating attenuation...\n");
    writeAttenuation(src, dst, dist);
    fprintf(stderr, "-> randomizing...\n");
    randomize(dst, dist * 0.5f, dist * 0.25f, dist * 0.5f);
    fprintf(stderr, "-> removing inner particles...\n");
    removeInnerParticles(dst, dist);
}

//------------------------------------------------------------------------------
/**
    Main function.
*/
int
main(int argc, char* argv[])
{
    int retval = 0;
    bool help;
    float subdiv;
    wfObject src;
    wfObject dst;
    FILE* in;
    FILE* out;

    fprintf(stderr, "-> wfcloud2\n");

    // get args
    help = wf_getboolarg(argc, argv, "-help");
    subdiv = wf_getfloatarg(argc, argv, "-subdiv", 12.0f);
    if (help)
    {
        fprintf(stderr, "wfcloud2 [-help] [-subdiv = 16]\n"
                "(C) 2001 A.Weissflog\n"
                "Generate cloud data from closed mesh\n"
                "-help -- show this help\n"
                "-subdiv -- number of subdivisions along longest axis\n");
        return 0;
    }

    // open files
    if (!wf_openfiles(argc, argv, in, out))
    {
        fprintf(stderr, "file open failed!\n");
        retval = 10;
        goto ende;
    }

    // load source mesh
    fprintf(stderr, "loading...\n");
    if (!src.load(in))
    {
        fprintf(stderr, "load failed!\n");
        retval = 10;
        goto ende;
    }

    // initialize OPCODE
    startupOpcode(src);

    // generate data
    doit(src, dst, subdiv);

    // shutdown OPCODE
    shutdownOpcode();

    // write result
    fprintf(stderr, "saving...\n");
    dst.save(out);

    wf_closefiles(in, out);

ende:
    fprintf(stderr, "<- wfcloud2\n");
    return retval;
}

//------------------------------------------------------------------------------
